<!DOCTYPE html>
<html>
<!-- json_osmall_webgl a program by NGUYEN.Chung (2015)
openstreetmap roads to html5 array -->
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
</head>
<body bgcolor="#FFFFFF" onunload="close();" >
	<div id="mydiv" style="position:absolute;top:0px;left:0px;z-index:200;" >
		<canvas id="canvas" style="border:none;top:0px;left:0px;" width="600" height="400"></canvas>
	</div>
	<div id="mydiv2" style="position:absolute;top:0px;left:0px;z-index:100;" >
		<canvas id="canvasgl" style="border:red 1px solid;top:0px;left:0px;" width="600" height="400"></canvas>

		<br />
		<button id="fullscreen"  onclick="sizescreen();">fullscreen</button>
		<input type="button" value="reload" onclick="subcombo()" />
		<input type="text"  readonly="readonly" id="msg" maxlength="65" size="65" />
	</div>

<script src="utils.js" type="text/javascript"></script>
<script src="osm.js" type="text/javascript"></script>
<script src="keys.js" type="text/javascript"></script>

<script src="https://maps.googleapis.com/maps/api/js?v=3&key=AIzaSyA9hK2lEmYMel53P17Ax6H5E952OSxiHdM" type="text/javascript" ></script>
<script src="lib/glMatrix-0.9.5.min.js"></script>
<script src="lib/webgl-utils.js"></script>
<script src="lib/base64binary.js"></script>
<script src="lib/vk_keys.js"></script>


<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
	//precision highp float;
    varying vec2 vTextureCoord;
    uniform sampler2D uSampler;
	uniform vec4 ucolor;

    void main(void) {
        gl_FragColor = texture2D(uSampler, vTextureCoord);
		if(ucolor.a>0.001){
	     if(gl_FragColor.a<0.5){discard;}else{
		   float s=vTextureCoord.y;
		   float r,g,b;
		   if(s<400.0){r=1.0;g=1.0;b=1.0;}
		   else if(s<800.0){r=0.7;g=0.7;b=0.7;}
		   else if(s<1200.0){r=0.4;g=0.4;b=0.4;}
		   else if(s<1600.0){r=1.0;g=0.4;b=0.4;}
		   else if(s<2000.0){r=0.7;g=0.7;b=1.5;}
		   else if(s<2400.0){r=0.5;g=0.5;b=1.0;}
		   else if(s<2800.0){r=1.0;g=1.0;b=0.5;}
		   else if(s<3200.0){r=0.7;g=1.5;b=0.7;}
		   else if(s<3600.0){r=0.5;g=1.0;b=0.5;}
		   else{r=0.3;g=0.7;b=0.5;}
		   gl_FragColor.a*=ucolor.a;
		   gl_FragColor.r*=ucolor.r*r;
		   gl_FragColor.g*=ucolor.g*g;
		   gl_FragColor.b*=ucolor.b*b;
		 }}
    }
</script>
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * (uMVMatrix * vec4(aVertexPosition, 1.0));
        vTextureCoord = aTextureCoord;
    }
</script>

<script>

var windx=600, windy=400;

var keys = new Keys();
document.body.onkeydown = keys.keydown ;
document.body.onkeyup = keys.keyup ;

var osm = new Osm();
var lat = 47.38994 ;
var lng = 0.69366 ;

// Angle de la cam&ra (tourner avec touches flèches droite et gauche)
var o1 = 0;

// Distance de lat et lon pour rectangle de donnes OSM
var dlat=0.0010,dlon=0.0014;
//var dlat=0.0040,dlon=0.0030;

// Les coordonnÃ©es du rectangle de données OSM
var	lat1 = lat-dlat/2,
	lon1 = lng-dlon/2;
var	lat2 = lat+dlat/2,
	lon2 = lng+dlon/2;

var nodes;
var nodekey,nodekey2,nodekey3,nkeymax=450;

var quit=0,tmsg=0,lat0=lat,lng0=lng,latx=lat,lngx=lng;
var scale = 0.3*windy/dlat,x0=x,y0=y;
var tmap=0,dxmax=12;

var tdraw=0,klon=1;

var x=0,y=0,z=0,o1=0,o2=-10,o3=0,vrun=1.10;
var cos1=0,sin1=0,cos2=0,sin2=0,cos3=0,sin3=0,do1=0,do2=0,do3=0;
var xmin=-30000,xmax=30000,ymin=-30000,ymax=30000;

var auxvar=null,auxvar2=null,auxvar3=null;

var canvas = document.getElementById('canvas');
var context = canvas.getContext('2d');
var gl,contextgl;
var canvasgl = document.getElementById('canvasgl');
//var contextgl = canvasgl.getContext('2d');
canvasgl.width=windx;
canvasgl.height=windy;

//contextgl.strokeStyle = '#ffff00';
//contextgl.lineWidth = 50;
//line(0,0,300,300);
context.width=windx;
context.height=windy;
context.lineWidth = 3;
context.fillStyle = '#ff0000';
context.font = "12pt Arial";


function line(x,y,x1,y1){
	contextgl.beginPath();
	contextgl.moveTo(x,y);
	contextgl.lineTo(x1,y1);
	contextgl.stroke();
}

function draw()
{
	context.clearRect (0,0,windx,windy);
	context.font = "12pt Arial";

	dbg("draw() ways:"+osm.ways.length);
	for(var i=0;i<osm.ways.length;i++)
	{
		var way=(osm.ways[i]),
			test=1;
		var waytype="none";

		if(way.tags){
			if(way.tags.highway){
				waytype = way.tags.highway;
			}
			if(way.tags.building){
				waytype="building";
			}
		}

		//if(waytype=="none" || waytype=="path"){
		//  test=0;}

		if(waytype=="building"){
			context.lineWidth = 1;
			context.strokeStyle = '#008fff';
		}else if(waytype=="motorway"){
			context.lineWidth = 4;
			context.strokeStyle = '#ff0000';
		}else if(waytype=="trunk"){
			context.lineWidth = 3;
			context.strokeStyle = '#cf0000';
		}else if(waytype=="track"){
			context.lineWidth = 3;
			context.strokeStyle = '#9f8000';
		}else if(waytype=="primary"){
			context.lineWidth = 2;
			context.strokeStyle = '#4f9f00';
		}else if(waytype=="secondary"){
			context.lineWidth = 1;
			context.strokeStyle = '#00ff00';
		}else if(waytype=="tertiary"){
			context.lineWidth = 1;
			context.strokeStyle = '#008f00';
		}else{//test=0;
			context.lineWidth = 1;
			context.strokeStyle = '#000000';
		}

		if(test==1){
			context.beginPath();
			for(var j=0;j<way.nodes.length;j++){
				var iNode=way.nodes[j];
				var nodes = osm.nodes ;
				if( nodes[iNode] ){
					var y=windy-windy*(nodes[iNode].lat-lat1)/(lat2-lat1);
					var x=windx*(nodes[iNode].lon-lon1)/(lon2-lon1);
					if(j==0){context.moveTo(x,y);}
					else{context.lineTo(x,y);}
				}
			}
			context.stroke();
			if(waytype=="building"){
				context.fillStyle = '#dfefff';
				context.fill();
			}
		}
	}// for ways
   context.fillStyle = '#ff0000';
   context.fillText("lat="+lat1+" lon="+lon1,20,20);
   context.fillText("nways="+i+" nnodes="+nnode,20,40);
   //alert("drawways="+i);
}

function timer(){
	return Date.now();
	//return (new Date()).getTime();//ms
}


function subhelp(){
	var crlf=String.fromCharCode(13)+String.fromCharCode(10);
	var msg="H => help "+crlf;
	msg+="3 => fullscreen"+crlf;
	msg+="shift+G => flyto geolocation"+crlf;
	msg+="pageup/pagedown => look up/down"+crlf;
	alert(msg);
	document.getElementById('msg').focus();
}

function close(){quit=1;}


function testkeys()
{
	var test=0,
		v=0.0000002*dtime;

	if(keys.up()){
		latx+=v*sin1;
		lngx+=v*cos1*klon;
		test=1;
	}
	if(keys.down()){
		latx -= v*sin1;
		lngx -= v*cos1*klon;
		test=1;
	}
	if(keys.left()){
		o1+=dtime*0.04;
	}
	if(keys.right()){
		o1-=dtime*0.04;
	}
	if(keys.vk_page_up()){
		o2+=dtime*0.04;
	}
	if(keys.vk_page_down()){
		o2-=dtime*0.04;
	}
	if(keys.vk_3()){
		sizescreen();
	}
	if(keys[vk_h]){
		subhelp();
	}
	if(keys[vk_g] && keys[vk_shift]){
		geolocate();
	}
	if(keys[vk_m]){
		dbg('testkeys() vk_m');
		tmap+=1;
		if(tmap>1){
			tmap=0;
			canvas.height = parseInt(canvasgl.height/3);
			context.clearRect(0,0,windx,windy);
		}
		else{
			canvas.height = parseInt(canvasgl.height);
		}
		keys.resetkeys();
	}
	x=((lngx-lng0)/klon)*scale;
	y=(latx-lat0)*scale;
	if(test==1 && !osm.loading){
		if(Math.max(Math.abs(x-x0),Math.abs(y-y0))>dxmax){
			osm.getways( lat, lng, dlat, dlon );
		}
	}

	if(tframe>tmsg+200){
	   tmsg=tframe;
	   var msg="arrow keys => move  /";
	   msg+=" x="+parseInt(x*10)/10;
	   msg+=" y="+parseInt(y*10)/10;
	   msg+=" o1="+parseInt(o1*10)/10;
	   msg+=" fps="+parseInt(fps*10)/10;
	   if(auxvar!=null){msg+=" aux="+auxvar;}
	   if(auxvar2!=null){msg+=" aux2="+auxvar2;}
	   if(auxvar3!=null){msg+=" aux3="+auxvar3;}
	   document.getElementById('msg').value=msg;
	}
    if(o2>85){o2=84;o1=180+o1-o3;o3=180;};
    if(o2<-85){o2=-84;o1=180+o1+o3;o3=0;};
	while(o1>180){o1-=360;}
	while(o1<-180){o1+=360;}
	while(o3>180){o3-=360;}
	while(o3<-180){o3+=360;}
    cos1=Math.cos(degtorad(o1)); sin1=Math.sin(degtorad(o1));
    cos2=Math.cos(degtorad(o2)); sin2=Math.sin(degtorad(o2));
    cos3=Math.cos(degtorad(o3)); sin3=Math.sin(degtorad(o3));

}//testkeys()

var tframe=0,tframe0=0,tfps=30,fps=10,dtime=1,tmsg=0,clearr,clearg,clearb,tskip=0;
var ttimeout=0,testloop=0,tskip2=0,tsrtm=0;

function tick(tt)
{
	//requestAnimFrame(tick);
	if(quit==0 && testloop==0 && ttimeout==0){
		testloop=1;requestAnimationFrame(tick);
	}else{
		testloop=0;
	}
	testkeys();
	tskip=0;
	//if(x<xmin){x+=xmax-xmin;tskip=1;};
	//if(x>xmax){x-=xmax-xmin;tskip=1;};
	//if(y<ymin){y+=ymax-ymin;tskip=1;};
	//if(y>ymax){y-=ymax-ymin;tskip=1;};
	if(tframe < tskip2+100){
		tskip=1;
	}
	gl.clearColor(1,1,1, 1.0);
	if(tskip==0){
		drawScene();
	}
	if(tdraw==1){
		tdraw=0;
		drawgl();
	}
	if(tmap==1){
		tmap=2;draw();
		setTimeout("draw();",500);
	}
	if(tupdatesoltexture==1){
		tupdatesoltexture=0;
		latsol0=latsol;lngsol0=lngsol;
		handleLoadedTexture(solTexture);
	}
	tframe0=tframe;
	tframe=timer();
	dtime=tframe-tframe0;
	if(dtime>1000){dtime=1000;}
	tfps+=(tframe-tframe0-tfps)*0.2;
	if(tfps<1){tfps=1;}
	if(tfps>1000){tfps=1000;}
	fps=1000/tfps;
	var dt=(tframe0+25-tframe);
	if(dt<10){dt=10};
	if(quit==0 && ttimeout){
		timeouttick=setTimeout("tick(0);",dt);
	}else{
		//if(tclose==0){requestAnimationFrame(tick);};
		if(quit==0 && testloop==0){testloop=1;requestAnimFrame(tick);
		}else{testloop=0;};
	}

}// tick()

document.getElementById('msg').focus();
document.getElementById('msg').value="arrow keys => move";

var icombo=0,combotext="";

function initwebgl()
{
	initGL(canvasgl);
	initShaders();
	initTexture();
	initBuffers();
	setTimeout("tick(0);",500);
}

function initGL(canvasgl){
       try {
           gl = canvasgl.getContext("experimental-webgl");
           //gl = canvasgl.getContext("webgl");
		   gl.viewportWidth = canvasgl.width;
           gl.viewportHeight = canvasgl.height;
       } catch (e) {alert("error initGL");}
       if (!gl) {
           alert("Could not initialise WebGL, sorry :-(");
       }
}

function getShader(gl, id) {
	var shaderScript = document.getElementById(id);
	if (!shaderScript) {
		return null;
	}

	var str = "";
	var k = shaderScript.firstChild;
	while (k) {
		if (k.nodeType == 3) {
			str += k.textContent;
		}
		k = k.nextSibling;
	}

	var shader;
	if (shaderScript.type == "x-shader/x-fragment") {
		shader = gl.createShader(gl.FRAGMENT_SHADER);
	} else if (shaderScript.type == "x-shader/x-vertex") {
		shader = gl.createShader(gl.VERTEX_SHADER);
	} else {
		return null;
	}

	gl.shaderSource(shader, str);
	gl.compileShader(shader);

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		alert(gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
}


var shaderProgram;

function initShaders() {
	var fragmentShader = getShader(gl, "shader-fs");
	var vertexShader = getShader(gl, "shader-vs");

	shaderProgram = gl.createProgram();
	gl.attachShader(shaderProgram, vertexShader);
	gl.attachShader(shaderProgram, fragmentShader);
	gl.linkProgram(shaderProgram);

	if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		alert("Could not initialise shaders");
	}

	gl.useProgram(shaderProgram);

	shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
	gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

	shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
	gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

	shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
	shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
	shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
	shaderProgram.colorUniform = gl.getUniformLocation(shaderProgram, "ucolor");
}

    var texturelist=[],itexturelist=0;

function handleLoadedTexture00(texture) {
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas2);
	//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.bindTexture(gl.TEXTURE_2D, null);
	texture.width=canvas2.width;
	texture.height=canvas2.height;
}
	function handleLoadedTexture0(texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.bindTexture(gl.TEXTURE_2D, null);
        texture.width=texture.image.width;
		texture.height=texture.image.height;
		//texture.image.src=null;
    }
	function handleLoadedTexture(texture) {
	    if(texture.image.src==null){return;}
	    handleLoadedTexture0(texture);
		itexturelist+=1;
		texturelist[itexturelist]=texture;
		setTimeout("deleteimagelist("+itexturelist+");",500);
	}
	function deleteimagelist(i){
	    var texture=texturelist[i];
		texture.image.src=null;
	}
    function gettexturedata(texture){
	  // Create a framebuffer backed by the texture
      var framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture, 0);
      // Read the contents of the framebuffer (data stores the pixel data)
      var data = new Uint8Array(texture.width * texture.height * 4);
      gl.readPixels(0,0,texture.width,texture.height,gl.RGBA,gl.UNSIGNED_BYTE,data);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.deleteFramebuffer(framebuffer);
	  return data;
    }

    var towerTexture,roadTexture,solTexture;
	var houseTexture,roofTexture;

    function gldeleteTexture(texture){
	    if(texture){gl.deleteTexture(texture);
		            texture.image.src=null;
	                };}
	function deletetextures(){
        //cancelRequestAnimationFrame();
	    for(var i=1;i<=itexturelist;i++){
		   gldeleteTexture(texturelist[i]);
		}
    }
    function initTexture() {
        roadTexture = gl.createTexture();
        roadTexture.image = new Image();
        roadTexture.image.onload = function () {
			handleLoadedTexture(roadTexture);
        }
        roadTexture.image.src = "textures/road.bmp";

        towerTexture = gl.createTexture();
        towerTexture.image = new Image();
        towerTexture.image.onload = function () {
			handleLoadedTexture(towerTexture);
        }
        towerTexture.image.src = "textures/tower1.jpg";

        /*houseTexture = gl.createTexture();
        houseTexture.image = new Image();
        houseTexture.image.onload = function () {
			handleLoadedTexture(houseTexture);
        }
        houseTexture.image.src = "tower3.jpg";
		*/
        roofTexture = gl.createTexture();
        roofTexture.image = new Image();
        roofTexture.image.onload = function () {
			handleLoadedTexture(roofTexture);
        }
        roofTexture.image.src = "textures/roof.jpg";

        solTexture = gl.createTexture();
        solTexture.image = new Image();
        solTexture.image.onload = function () {
			tupdatesoltexture=1;
			//handleLoadedTexture(solTexture);
        }
        updatesoltexture();
		//solTexture.image.src = "map2.jpg";

        }

var tupdatesoltexture=0;

function updatesoltexture()
{
		var lat000=lat,lng000=lng;
		latsol=lat;lngsol=lng;
		getworldxy(zoom,lat,lng);
        getlatlng(zoom,worldx+256,worldy+256)
		dlatsol=lat-latsol;dlngsol=lng-lngsol;
		lat=lat000;lng=lng000;
		solTexture.image.crossOrigin = "anonymous";
        solTexture.image.src = getmap(zoom,lat,lng,512,"png",2);//map2jpg;
}

var latsol=lat,lngsol=lng,dlatsol=1,dlngsol=1;
var latsol0=lat,lngsol0=lng;

function getmap(zoom,lat,lng,size,type0,scale)
{
	var type=type0;
	if(type=="jpg"){type="jpg-baseline";}
	var mapstyle="&style=feature:road%7Cvisibility:off&style=element:labels%7Cvisibility:off&style=element:geometry.stroke%7Cvisibility:off";
	return "https://maps.googleapis.com/maps/api/staticmap?key=AIzaSyA9hK2lEmYMel53P17Ax6H5E952OSxiHdM&center="+lat+","+lng+"&zoom="+zoom+"&scale="+scale+"&size="+size+"x"+size+"&maptype=satellite&format="+type+mapstyle;
}

var mvMatrix = mat4.create();
var mvMatrixStack = [];
var pMatrix = mat4.create();

function mvPushMatrix() {
    var copy = mat4.create();
    mat4.set(mvMatrix, copy);
    mvMatrixStack.push(copy);
}

function mvPopMatrix() {
    if (mvMatrixStack.length == 0) {
        throw "Invalid popMatrix!";
    }
    mvMatrix = mvMatrixStack.pop();
}

	 var colorr=1.0,colorg=1.0,colorb=1.0,colora=1.0;
     function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
        gl.uniform4f(shaderProgram.colorUniform,colorr,colorg,colorb,colora);
    }

    var tfoot=1;
	function drawScene() {
    gl.clearColor(0.85,0.85,1.0, 1.0);
		gl.viewport(0, 0, windx,windy);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    	mat4.perspective(47, gl.viewportWidth / gl.viewportHeight, 0.2, 6000.0, pMatrix);

		if(tmap==0){
		   mat4.lookAt([x,y,z+0.5],[x+cos1*cos2,y+sin1*cos2,z+sin2+0.5],[0,0,1],mvMatrix);
		}else{
		   return;
		   //mat4.lookAt([x,y,z+200.5],[x+cos1*cos2,y+sin1*cos2,z+sin2+0.5],[0,0,1],mvMatrix);
		}

		gl.useProgram(shaderProgram);
		drawroads();
		drawtowers();
		drawroofs();
		drawbouss();
		drawsol();

		}
		
function drawroads(){
    mvPushMatrix();
    //mat4.identity(mvMatrix);
	mat4.translate(mvMatrix, [0,0,0]);
    var sc=0.5;
    mat4.scale(mvMatrix,[sc,sc,sc]);
	gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D,  roadTexture);
    gl.uniform1i(shaderProgram.samplerUniform, 0);

	gl.bindBuffer(gl.ARRAY_BUFFER, roadVertexTextureCoordBuffer);
    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, roadVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, roadVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, roadVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    colorr=1;colorg=1;colorb=1;colora=1;
	setMatrixUniforms();
    colorr=1;colorg=1;colorb=1;colora=1;
    gl.drawArrays(gl.TRIANGLES, 0, roadVertexPositionBuffer.numItems);
	mvPopMatrix();
}
function drawtowers(){
    gl.disable(gl.CULL_FACE);
    gl.enable(gl.DEPTH_TEST);
    mvPushMatrix();
    //mat4.identity(mvMatrix);
	mat4.translate(mvMatrix, [0,0,0]);
    var sc=0.5;
    mat4.scale(mvMatrix,[sc,sc,1]);
	gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D,  towerTexture);
    gl.uniform1i(shaderProgram.samplerUniform, 0);

	gl.bindBuffer(gl.ARRAY_BUFFER, towerVertexTextureCoordBuffer);
    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, towerVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, towerVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, towerVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    colorr=1;colorg=1;colorb=1;colora=1;
	setMatrixUniforms();
    colorr=1;colorg=1;colorb=1;colora=1;
    gl.drawArrays(gl.TRIANGLES, 0, towerVertexPositionBuffer.numItems);
	mvPopMatrix();
}
function drawroofs(){
    gl.disable(gl.CULL_FACE);
    gl.enable(gl.DEPTH_TEST);
    mvPushMatrix();
    //mat4.identity(mvMatrix);
	mat4.translate(mvMatrix, [0,0,0]);
    var sc=0.5;
    mat4.scale(mvMatrix,[sc,sc,1]);
	gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D,  roofTexture);
    gl.uniform1i(shaderProgram.samplerUniform, 0);

	gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexTextureCoordBuffer);
    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, roofVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, roofVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    colorr=1;colorg=1;colorb=1;colora=1;
	setMatrixUniforms();
    colorr=1;colorg=1;colorb=1;colora=1;
    gl.drawArrays(gl.TRIANGLES, 0, roofVertexPositionBuffer.numItems);
	mvPopMatrix();
}

function drawbouss(){
  var xx=windx-40,yy=40,r=14;
  context.clearRect (xx-40,yy-40,xx+40,yy+40);
  context.font = "12pt Arial";
  context.fillText("+",xx,yy);
  context.fillText("S",xx+r*cos1,yy+r*sin1);
  context.fillText("N",xx-r*cos1,yy-r*sin1);
  context.fillText("E",xx+r*sin1,yy-r*cos1);
  context.fillText("W",xx-r*sin1,yy+r*cos1);
}

var xsol=0,ysol=0,zsol=-0.1;

function drawsol()
{

	//xsol=parseInt(x/100)*100;
	//ysol=parseInt(y/100)*100;
	xsol=((lngsol0-lng0)/klon)*scale;
	ysol=(latsol0-lat0)*scale;


	mvPushMatrix();
    //mat4.identity(mvMatrix);
	mat4.translate(mvMatrix, [xsol,ysol,zsol]);
    var sc=100;
	var scx=(dlngsol/klon)*scale;
	var scy=dlatsol*scale;
    if(Math.abs(xsol-x)>scx*0.7 || Math.abs(ysol-y)>scy*0.7){
	   if(tupdatesoltexture==0){
	      tupdatesoltexture=2;updatesoltexture();}}
	mat4.scale(mvMatrix,[scx,scy,sc]);
	gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D,  solTexture);
    gl.uniform1i(shaderProgram.samplerUniform, 0);

	gl.bindBuffer(gl.ARRAY_BUFFER, solVertexTextureCoordBuffer);
    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, solVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, solVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, solVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    //colorr=1.34;colorg=1.34;colorb=1.34;colora=1;
    colorr=1;colorg=1;colorb=1;colora=1;
	setMatrixUniforms();
    colorr=1;colorg=1;colorb=1;colora=1;
    gl.drawArrays(gl.TRIANGLES, 0, solVertexPositionBuffer.numItems);
	mvPopMatrix();
}

	var index=0,indexroad=0,itextroad=0;
	var indextower=0,itexttower=0;
	var indexhouse=0,itexthouse=0;
	var indexroof=0,itextroof=0;
	function append(tab,values){
	  for(var i=0;i<values.length;i++){
	     tab[index]=values[i];index+=1;
	  }
	}

	var roadVertexPositionBuffer;
	var roadVertexTextureCoordBuffer;
	var roadvertices,roadtextureCoords;
	var towerVertexPositionBuffer;
	var towerVertexTextureCoordBuffer;
	var towervertices,towertextureCoords;
	var solVertexPositionBuffer;
	var solVertexTextureCoordBuffer;
	var solvertices,soltextureCoords;
	var houseVertexPositionBuffer;
	var houseVertexTextureCoordBuffer;
	var housevertices,housetextureCoords;
	var roofVertexPositionBuffer;
	var roofVertexTextureCoordBuffer;
	var roofvertices,rooftextureCoords;

	var maxvertice=20000*6;
	function initBuffers() {
        roadVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, roadVertexPositionBuffer);
        roadvertices = new Float32Array(3*maxvertice);
		var px=0,py=0,pz=0;
		index=0;
		for(var i=0;i<maxvertice;i++){
		   append(roadvertices,[
             px,py,pz
            ]);

		}
        gl.bufferData(gl.ARRAY_BUFFER, (roadvertices), gl.STATIC_DRAW);
        roadVertexPositionBuffer.itemSize = 3;
        roadVertexPositionBuffer.numItems = maxvertice;

        roadVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, roadVertexTextureCoordBuffer);
        roadtextureCoords = new Float32Array(2*maxvertice);
		index=0;
		for (var i=0;i<maxvertice;i++) {
		   append(roadtextureCoords,[
             0,0
			 ]);
		}
        gl.bufferData(gl.ARRAY_BUFFER, (roadtextureCoords), gl.STATIC_DRAW);
        roadVertexTextureCoordBuffer.itemSize = 2;
        roadVertexTextureCoordBuffer.numItems = maxvertice;//24;

        towerVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, towerVertexPositionBuffer);
        towervertices = new Float32Array(3*maxvertice);
		//var px=0,py=0,pz=0;
		index=0;
		for(var i=0;i<maxvertice;i++){
		   append(towervertices,[
             px,py,pz
            ]);

		}
        gl.bufferData(gl.ARRAY_BUFFER, (towervertices), gl.STATIC_DRAW);
        towerVertexPositionBuffer.itemSize = 3;
        towerVertexPositionBuffer.numItems = maxvertice;

        towerVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, towerVertexTextureCoordBuffer);
        towertextureCoords = new Float32Array(2*maxvertice);
		index=0;
		for (var i=0;i<maxvertice;i++) {
		   append(towertextureCoords,[
             0,0
			 ]);
		}
        gl.bufferData(gl.ARRAY_BUFFER, (towertextureCoords), gl.STATIC_DRAW);
        towerVertexTextureCoordBuffer.itemSize = 2;
        towerVertexTextureCoordBuffer.numItems = maxvertice;//24;

        solVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, solVertexPositionBuffer);
        solvertices = new Float32Array(3*6);
		px=1;py=1;pz=0;
		index=0;
		   append(solvertices,[
             -px,-py,pz, px,-py,pz, -px,py,pz,
              px,-py,pz, px,py,pz,  -px,py,pz
            ]);

        gl.bufferData(gl.ARRAY_BUFFER, (solvertices), gl.STATIC_DRAW);
        solVertexPositionBuffer.itemSize = 3;
        solVertexPositionBuffer.numItems = 6;

        solVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, solVertexTextureCoordBuffer);
        soltextureCoords = new Float32Array(2*6);
		index=0;
		var s1=1;
	    append(soltextureCoords,[
             0,0, s1,0, 0,s1,
             s1,0, s1,s1, 0,s1
			 ]);
        gl.bufferData(gl.ARRAY_BUFFER, (soltextureCoords), gl.STATIC_DRAW);
        solVertexTextureCoordBuffer.itemSize = 2;
        solVertexTextureCoordBuffer.numItems = 6;

        houseVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
        housevertices = new Float32Array(3*maxvertice);
		//var px=0,py=0,pz=0;
		index=0;
		for(var i=0;i<maxvertice;i++){
		   append(housevertices,[
             px,py,pz
            ]);

		}
        gl.bufferData(gl.ARRAY_BUFFER, (housevertices), gl.STATIC_DRAW);
        houseVertexPositionBuffer.itemSize = 3;
        houseVertexPositionBuffer.numItems = maxvertice;

        houseVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexTextureCoordBuffer);
        housetextureCoords = new Float32Array(2*maxvertice);
		index=0;
		for (var i=0;i<maxvertice;i++) {
		   append(housetextureCoords,[
             0,0
			 ]);
		}
        gl.bufferData(gl.ARRAY_BUFFER, (housetextureCoords), gl.STATIC_DRAW);
        houseVertexTextureCoordBuffer.itemSize = 2;
        houseVertexTextureCoordBuffer.numItems = maxvertice;//24;

        roofVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexPositionBuffer);
        roofvertices = new Float32Array(3*maxvertice);
		//var px=0,py=0,pz=0;
		index=0;
		for(var i=0;i<maxvertice;i++){
		   append(roofvertices,[
             px,py,pz
            ]);

		}
        gl.bufferData(gl.ARRAY_BUFFER, (roofvertices), gl.STATIC_DRAW);
        roofVertexPositionBuffer.itemSize = 3;
        roofVertexPositionBuffer.numItems = maxvertice;

        roofVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexTextureCoordBuffer);
        rooftextureCoords = new Float32Array(2*maxvertice);
		index=0;
		for (var i=0;i<maxvertice;i++) {
		   append(rooftextureCoords,[
             0,0
			 ]);
		}
        gl.bufferData(gl.ARRAY_BUFFER, (rooftextureCoords), gl.STATIC_DRAW);
        roofVertexTextureCoordBuffer.itemSize = 2;
        roofVertexTextureCoordBuffer.numItems = maxvertice;//24;

		}

function drawgl()
{
	context.clearRect (0,0,windx,windy);
	indexroad=0;
	itextroad=0;
	indextower=0;
	itexttower=0;
	indexhouse=0;
	itexthouse=0;
	indexroof=0;
	itextroof=0;

	if(Math.max(Math.abs(latx-lat0),Math.abs(lngx-lng0))>0.01)
	{
		lat0=latx;
		lng0=lngx;
	}

	dbg('drawgl()');
	for(var i=0;i<osm.ways.length;i++)
	{
		var way=(osm.ways[i]),
			test=1;
		var xx=0,xxx=0,yy=0,yyy=0,r=1,dr=1;
		var dx=1,dy=1,dxx=0,dyy=0,dx0=0,dy0=0,zz=0,zzz=0;
		var s=0,t=0,tt=0;
		var waytype="none";

		if(way.tags)
		{
		  if(way.tags.highway){
			waytype=way.tags.highway;
		  }
		  if(way.tags.building){
			waytype="building";
		  }
		}

		//if(waytype=="none" || waytype=="path"){
		//  test=0;}
		if(waytype=="building"){
			addtower(way);
			test=0;
			//context.lineWidth = 1;
			//context.strokeStyle = '#008fff';
		}else if(waytype=="motorway"){
			r=4;
			//context.lineWidth = 4;
			//context.strokeStyle = '#ff0000';
		}else if(waytype=="trunk"){
			r=3;
			//context.lineWidth = 3;
			//context.strokeStyle = '#cf0000';
		}else if(waytype=="primary"){
			r=2.5;
			//context.lineWidth = 2;
			//context.strokeStyle = '#4f9f00';
		}else if(waytype=="secondary"){
			r=2;
			//context.lineWidth = 1;
			//context.strokeStyle = '#00ff00';
		}else if(waytype=="tertiary"){
			r=1.2;
			//context.lineWidth = 1;
			//context.strokeStyle = '#008f00';
		}else{//test=0;
			r=0.8;
			//context.lineWidth = 1;
			//context.strokeStyle = '#000000';
		}
    
		if(test==1)
		{
			dbg('drawgl() ...');
			//context.beginPath();
			var jmax=way.nodes.length-1;
			var jstart=0;
			for(var j=0;j<=jmax;j++)
			{
				var idNode=way.nodes[j];
				if(osm.nodes[idNode])
				{
					node = osm.nodes[idNode];
					xxx=xx;yyy=yy;zzz=zz;
					yy=(node.lat-lat0)*scale*2;
					xx=((node.lon-lng0)/klon)*scale*2;
					zz=0;
					dx0=dx;dy0=dy;
					if(jstart==0){
						jstart=1;//context.moveTo(xx,yy);
					} else {//context.lineTo(xx,yy);
						dxx=xx-xxx;dyy=yy-yyy;
						dr=Math.max(0.00001,Math.sqrt(dxx*dxx+dyy*dyy));
						dx=-r*dyy/dr;dy=r*dxx/dr;
						if(j==1){
							dx0=dx;dy0=dy;
							xxx-=dy*0.4;yyy+=dx*0.4;
						}
						if(j==jmax){
							xx+=dy*0.4;yy-=dx*0.4;
						}
						index=indexroad;
						append(
							roadvertices,[
							xxx-dx0,yyy-dy0,zzz,
							xx+dx,yy+dy,zz,
							xxx+dx0,yyy+dy0,zzz,
							xxx-dx0,yyy-dy0,zzz,
							xx-dx,yy-dy,zz,
							xx+dx,yy+dy,zz
						]);
						indexroad=index;
						s=1;tt=t;t+=dr*0.3;
						index=itextroad;
						append(
							roadtextureCoords,[
							0,tt,
							1,t,
							1,tt,
							0,tt,
							0,t,
							1,t
						]);
						itextroad=index;
					}
				}
			} // for j<= jmax
			//context.stroke();
		}
	}// for osm.ways

	gl.bindBuffer(gl.ARRAY_BUFFER, roadVertexPositionBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, (roadvertices), gl.STATIC_DRAW);
	roadVertexPositionBuffer.itemSize = 3;
	roadVertexPositionBuffer.numItems = indexroad/3;

	gl.bindBuffer(gl.ARRAY_BUFFER, roadVertexTextureCoordBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, (roadtextureCoords), gl.STATIC_DRAW);
	roadVertexTextureCoordBuffer.itemSize = 2;
	roadVertexTextureCoordBuffer.numItems = itextroad/2;

	gl.bindBuffer(gl.ARRAY_BUFFER, towerVertexPositionBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, (towervertices), gl.STATIC_DRAW);
	towerVertexPositionBuffer.itemSize = 3;
	towerVertexPositionBuffer.numItems = indextower/3;

	gl.bindBuffer(gl.ARRAY_BUFFER, towerVertexTextureCoordBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, (towertextureCoords), gl.STATIC_DRAW);
	towerVertexTextureCoordBuffer.itemSize = 2;
	towerVertexTextureCoordBuffer.numItems = itexttower/2;

	/*gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, (housevertices), gl.STATIC_DRAW);
	houseVertexPositionBuffer.itemSize = 3;
	houseVertexPositionBuffer.numItems = indexhouse/3;

	gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexTextureCoordBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, (housetextureCoords), gl.STATIC_DRAW);
	houseVertexTextureCoordBuffer.itemSize = 2;
	houseVertexTextureCoordBuffer.numItems = itexthouse/2;
	*/
	gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexPositionBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, (roofvertices), gl.STATIC_DRAW);
	roofVertexPositionBuffer.itemSize = 3;
	roofVertexPositionBuffer.numItems = indexroof/3;

	gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexTextureCoordBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, (rooftextureCoords), gl.STATIC_DRAW);
	roofVertexTextureCoordBuffer.itemSize = 2;
	roofVertexTextureCoordBuffer.numItems = itextroof/2;

	//lat0=lat;lng0=lng;
	x0=x;y0=y;

	context.font = "12pt Arial";
	context.fillStyle = '#ff0000';
	var latt=parseInt(lat*10000)/10000;
	var lngg=parseInt(lng*10000)/10000;
	context.fillText("lat="+latt+" lon="+lngg,20,20);
	context.fillText("nways="+i+" nnodes="+nnode,20,40);
	context.fillText("M => map",20,60);
	//alert("drawways="+i);
	//loading=0;

} // function drawgl()


function addtower(way)
{
	var xx=0,xxx=0,yy=0,yyy=0,r=1,dr=1;
	var dxx=0,dyy=0,zz=0,zzz=0;
	var s=0,t=0,tt=0;
	var h=1;
	if(way.tags){
		if(way.tags.height){
			h=way.tags.height/6;
		}
		else if(way.tags["building:height"]){
			h=way.tags["building:height"]/6;
		}
		else if(way.tags["building:levels"]){
			h=way.tags["building:levels"]/4;
		}
	}

	var jmax= way.nodes.length-1;
	var larg=1,
		ilarg = way.nodes[parseInt(jmax/2)]
		i0 = way.nodes[0];
	var xmid=0,ymid=0,zmid=0;
   
	if( osm.nodes[ilarg] && osm.nodes[i0] )
	{
		yyy=(osm.nodes[i0].lat-lat0)*scale*2;
		xxx=((osm.nodes[i0].lon-lng0)/klon)*scale*2;
		yy=(osm.nodes[ilarg].lat-lat0)*scale*2;
		xx=((osm.nodes[ilarg].lon-lng0)/klon)*scale*2;
		larg=Math.max(Math.abs(xx-xxx),Math.abs(yy-yyy));
		xmid=(xx+xxx)/2;
		ymid=(yy+yyy)/2;
		zmid=0;
	}

	if(h>3){//tower
		dbg('addtower() tower');
		var jstart=0;
		for(var j=0;j<=jmax;j++){
			var inode=way.nodes[j];
			if(osm.nodes[inode]){
				xxx=xx;yyy=yy;zzz=zz;
				yy=(osm.nodes[inode].lat-lat0)*scale*2;
				xx=((osm.nodes[inode].lon-lng0)/klon)*scale*2;
				zz=0;
				if(jstart==0){
					jstart=1;//context.moveTo(xx,yy);
				}else{//context.lineTo(xx,yy);
					dxx=xx-xxx;dyy=yy-yyy;
					dr=Math.max(0.00001,Math.sqrt(dxx*dxx+dyy*dyy));
					index=indextower;
					append(towervertices,[
					xxx,yyy,zzz,
					xxx,yyy,zzz+h,
					xx,yy,zz,
					xxx,yyy,zzz+h,
					xx,yy,zz+h,
					xx,yy,zz
					]);
					indextower=index;
					var s0=(parseInt(h*10.5)%10)*400;
					if(h<=3){
						s=s0+1+parseInt(h*2);tt=t;t+=2*dr;
					}
					else{
						s=s0+1+parseInt(h*2);tt=t;t+=dr;
					}
					index=itexttower;
					append(towertextureCoords,[
						tt,s0,
						tt,s,
						t,s0,
						tt,s,
						t,s,
						t,s0
					]);
					itexttower=index;
				}
			}
		}
	}else if(larg>12*h){//commercial
		dbg('addtower() commercial');
		var jstart=0;
		for(var j=0;j<=jmax;j++){
			var inode=way.nodes[j];
			if(osm.nodes[inode].lat){
				xxx=xx;yyy=yy;zzz=zz;
				yy=(osm.nodes[inode].lat-lat0)*scale*2;
				xx=((osm.nodes[inode].lon-lng0)/klon)*scale*2;
				zz=0;
				if(jstart==0){jstart=1;//context.moveTo(xx,yy);
				}else{//context.lineTo(xx,yy);
					dxx=xx-xxx;dyy=yy-yyy;
					dr=Math.max(0.00001,Math.sqrt(dxx*dxx+dyy*dyy));
					index=indextower;
					append(towervertices,[
					xxx,yyy,zzz,
					xxx,yyy,zzz+h,
					xx,yy,zz,
					xxx,yyy,zzz+h,
					xx,yy,zz+h,
					xx,yy,zz
					]);
					indextower=index;
					var s0=(parseInt(h*10.5)%10)*400;
					if(h<=3){s=s0+1+parseInt(h*2);tt=t;t+=2*dr/3.5;}
					else{s=s0+1+parseInt(h*2);tt=t;t+=dr/3.5;}
					index=itexttower;
					append(towertextureCoords,[
						tt,s0,
						tt,s,
						t,s0,
						tt,s,
						t,s,
						t,s0
					]);
					itexttower=index;
				}
			}
		}
	}else{//house
		dbg('addtower() house');
		var jstart=0;
		var xxmin=xmid+999999,xxmax=xmid-999999;
		var yymin=ymid+999999,yymax=ymid-999999;
		for(var j=0;j<=jmax;j++){
			var inode=way.nodes[j];
			if(osm.nodes[inode]){
				xxx=xx;yyy=yy;zzz=zz;
				yy=(osm.nodes[inode].lat-lat0)*scale*2;
				xx=((osm.nodes[inode].lon-lng0)/klon)*scale*2;
				zz=0;
				if(xx<xxmin){xxmin=xx;}
				if(xx>xxmax){xxmax=xx;}
				if(yy<yymin){yymin=yy;}
				if(yy>yymax){yymax=yy;}
				if(jstart==0){jstart=1;//context.moveTo(xx,yy);
				}else{//context.lineTo(xx,yy);
				dxx=xx-xxx;dyy=yy-yyy;
				dr=Math.max(0.00001,Math.sqrt(dxx*dxx+dyy*dyy));
				index=indextower;
				append(towervertices,[
				xxx,yyy,zzz,
				xxx,yyy,zzz+h,
				xx,yy,zz,
				xxx,yyy,zzz+h,
				xx,yy,zz+h,
				xx,yy,zz
				]);
				indextower=index;
				var s0=(parseInt(h*10.5)%10)*400;
				if(h<=3){s=s0+1+parseInt(h*2);tt=t;t+=2*dr;}
				else{s=s0+1+parseInt(h*2);tt=t;t+=dr;}
					index=itexttower;
					append(towertextureCoords,[
						tt,s0,
						tt,s,
						t,s0,
						tt,s,
						t,s,
						t,s0
					]);
					itexttower=index;
				}
			}
		}
		xmid=(xxmin+xxmax)/2;
		ymid=(yymin+yymax)/2;
		var hh=h*0.2;
		hh=Math.max(hh,Math.min(xxmax-xxmin,yymax-yymin)/12);
		hh=h+hh;
		tt=0;t=0;
		for(var j=0;j<=jmax;j++){
			var inode=way.nodes[j];
			if(osm.nodes[inode]){
				xxx=xx;yyy=yy;zzz=zz;
				yy=(osm.nodes[inode].lat-lat0)*scale*2;
				xx=((osm.nodes[inode].lon-lng0)/klon)*scale*2;
				zz=0;
				if(jstart==0){
					jstart=1;//context.moveTo(xx,yy);
				}else{//context.lineTo(xx,yy);
					dxx=xx-xxx;dyy=yy-yyy;
					dr=Math.max(0.00001,Math.abs(dxx)+Math.abs(dyy));
					index=indexroof;
					append(roofvertices,[
						xmid,ymid,zmid+hh,
						xx,yy,zz+h,
						xxx,yyy,zzz+h
					]);
					indexroof=index;
					tt=t;t+=dr;
					index=itextroof;
					append(rooftextureCoords,[
						0.5,1,
						t-parseInt(t),0,
						tt-parseInt(tt),0
					]);
					itextroof=index;
				}
			}
		}
	}
}

var MERCATOR_RANGE = 256;

var pixeloriginx=MERCATOR_RANGE / 2;
var pixeloriginy=MERCATOR_RANGE / 2;
var pixelsPerLonDegree = MERCATOR_RANGE / 360;
var pixelsPerLonRadian = MERCATOR_RANGE / (2 * Math.PI);

var pointx=0,pointy=0,worldx=0,worldy=0,zoom=15;
function MercatorLatLngtoPoint(lat,lng) {
  pointx = pixeloriginx + lng * pixelsPerLonDegree;
  // NOTE(appleton): Truncating to 0.9999 effectively limits latitude to
  // 89.189.  This is about a third of a tile past the edge of the world tile.
  var siny=Math.min(Math.max(Math.sin(degtorad(lat)),-0.9999),0.9999);
  pointy = pixeloriginy+0.5*Math.log((1+siny)/(1-siny))*pixelsPerLonRadian;
};

function MercatorPointtoLatLng(pointx,pointy) {
  lng=(pointx-pixeloriginx)/pixelsPerLonDegree;
  var latRadians = (pointy-pixeloriginy)/pixelsPerLonRadian;
  lat=radiansToDegrees(2*Math.atan(Math.exp(latRadians))-Math.PI/2);
};
function getlatlng(zoom,worldx,worldy){
pointx = worldx / Math.pow(2,zoom);
pointy = worldy / Math.pow(2,zoom);
MercatorPointtoLatLng(pointx,pointy);
}
function getworldxy(zoom,lat,lng){
MercatorLatLngtoPoint(lat,lng);
worldx=pointx*Math.pow(2,zoom);
worldy=pointy*Math.pow(2,zoom);
}

var fullscreen=0;

function sizescreen()
{
	    if(fullscreen==0){fullscreen=1;
		                  canvas.width  = parseInt(window.innerWidth*0.98);
                          canvas.height = parseInt(window.innerHeight*0.94);
						 }else{fullscreen=0;
						  canvas.width=600;canvas.height=400;};
	canvas.width  = Math.min(canvas.width,window.innerWidth-20);
    canvas.height = Math.min(canvas.height,window.innerHeight-36);
	canvasgl.width  = Math.min(canvas.width,window.innerWidth-20);
    canvasgl.height = Math.min(canvas.height,window.innerHeight-36);
	gl.viewportWidth = canvas.width;
    gl.viewportHeight = canvas.height;
			windx = canvas.width;
            windy = canvas.height;
            gl.viewport(0, 0, windx,windy);
            document.getElementById("canvas").setAttribute("style",
	         "border: none;top:0px;left:0px;");
    canvas.height = parseInt(canvasgl.height/3);
	tmap=0;
    document.getElementById("msg").focus();
}

var geolocation="";

function geolocate()
{
	geolocation = "paris france";
	geolocation=window.prompt("flyto : enter address or location");
	//alert("geolocation="+geolocation);
	if (geolocation.length>0){
		var geocoder = new google.maps.Geocoder();
		geocoder.geocode( { 'address': geolocation}, function(results, status) {
		if (status == google.maps.GeocoderStatus.OK) {
		var latlng=results[0].geometry.location;
		lat=latlng.lat();
		lng=latlng.lng();
		flytolat=lat;flytolng=lng;flytoname=geolocation;
		icombo=0;
		document.getElementById('combo')[icombo].text=flytoname;
		document.getElementById('combo').selectedIndex=icombo;
		latx=lat;lngx=lng;tmap=0;
		osm.getways( lat, lng, dlat, dlon );
		} else {
		alert('Geolocation not found ! ' + status);
		}
		});
	}
	document.getElementById('msg').focus();
}

osm.getways( lat, lng, dlat, dlon );
setTimeout("initwebgl();",1000);

</script>
</body>
</html>
